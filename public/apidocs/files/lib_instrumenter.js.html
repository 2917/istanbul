<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/instrumenter.js - The Istanbul API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="The Istanbul API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CloverReport.html">CloverReport</a></li>
            
                <li><a href="../classes/CoberturaReport.html">CoberturaReport</a></li>
            
                <li><a href="../classes/Collector.html">Collector</a></li>
            
                <li><a href="../classes/Config.html">Config</a></li>
            
                <li><a href="../classes/Configuration.html">Configuration</a></li>
            
                <li><a href="../classes/ContentWriter.html">ContentWriter</a></li>
            
                <li><a href="../classes/FileWriter.html">FileWriter</a></li>
            
                <li><a href="../classes/Hook.html">Hook</a></li>
            
                <li><a href="../classes/HookOptions.html">HookOptions</a></li>
            
                <li><a href="../classes/HtmlReport.html">HtmlReport</a></li>
            
                <li><a href="../classes/Instrumenter.html">Instrumenter</a></li>
            
                <li><a href="../classes/InstrumentOptions.html">InstrumentOptions</a></li>
            
                <li><a href="../classes/Istanbul.html">Istanbul</a></li>
            
                <li><a href="../classes/JsonReport.html">JsonReport</a></li>
            
                <li><a href="../classes/JsonSummaryReport.html">JsonSummaryReport</a></li>
            
                <li><a href="../classes/LcovOnlyReport.html">LcovOnlyReport</a></li>
            
                <li><a href="../classes/LcovReport.html">LcovReport</a></li>
            
                <li><a href="../classes/LookupStore.html">LookupStore</a></li>
            
                <li><a href="../classes/MemoryStore.html">MemoryStore</a></li>
            
                <li><a href="../classes/NoneReport.html">NoneReport</a></li>
            
                <li><a href="../classes/ObjectUtils.html">ObjectUtils</a></li>
            
                <li><a href="../classes/Report.html">Report</a></li>
            
                <li><a href="../classes/Reporter.html">Reporter</a></li>
            
                <li><a href="../classes/ReportingOptions.html">ReportingOptions</a></li>
            
                <li><a href="../classes/Store.html">Store</a></li>
            
                <li><a href="../classes/TeamcityReport.html">TeamcityReport</a></li>
            
                <li><a href="../classes/TextReport.html">TextReport</a></li>
            
                <li><a href="../classes/TextSummaryReport.html">TextSummaryReport</a></li>
            
                <li><a href="../classes/TmpStore.html">TmpStore</a></li>
            
                <li><a href="../classes/Writer.html">Writer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/config.html">config</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/main.html">main</a></li>
            
                <li><a href="../modules/report.html">report</a></li>
            
                <li><a href="../modules/store.html">store</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/instrumenter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright (c) 2012, Yahoo! Inc.  All rights reserved.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

/*global esprima, escodegen, window */
(function (isNode) {
    &quot;use strict&quot;;
    var SYNTAX,
        nodeType,
        ESP = isNode ? require(&#x27;esprima&#x27;) : esprima,
        ESPGEN = isNode ? require(&#x27;escodegen&#x27;) : escodegen,  //TODO - package as dependency
        crypto = isNode ? require(&#x27;crypto&#x27;) : null,
        LEADER_WRAP = &#x27;(function () { &#x27;,
        TRAILER_WRAP = &#x27;\n}());&#x27;,
        COMMENT_RE = /^\s*istanbul\s+ignore\s+(if|else|next)(?=\W|$)/,
        astgen,
        preconditions,
        cond,
        isArray = Array.isArray;

    /* istanbul ignore if: untestable */
    if (!isArray) {
        isArray = function (thing) { return thing &amp;&amp;  Object.prototype.toString.call(thing) === &#x27;[object Array]&#x27;; };
    }

    if (!isNode) {
        preconditions = {
            &#x27;Could not find esprima&#x27;: ESP,
            &#x27;Could not find escodegen&#x27;: ESPGEN,
            &#x27;JSON object not in scope&#x27;: JSON,
            &#x27;Array does not implement push&#x27;: [].push,
            &#x27;Array does not implement unshift&#x27;: [].unshift
        };
        /* istanbul ignore next: untestable */
        for (cond in preconditions) {
            if (preconditions.hasOwnProperty(cond)) {
                if (!preconditions[cond]) { throw new Error(cond); }
            }
        }
    }

    function generateTrackerVar(filename, omitSuffix) {
        var hash, suffix;
        if (crypto !== null) {
            hash = crypto.createHash(&#x27;md5&#x27;);
            hash.update(filename);
            suffix = hash.digest(&#x27;base64&#x27;);
            //trim trailing equal signs, turn identifier unsafe chars to safe ones + =&gt; _ and / =&gt; $
            suffix = suffix.replace(new RegExp(&#x27;=&#x27;, &#x27;g&#x27;), &#x27;&#x27;)
                .replace(new RegExp(&#x27;\\+&#x27;, &#x27;g&#x27;), &#x27;_&#x27;)
                .replace(new RegExp(&#x27;/&#x27;, &#x27;g&#x27;), &#x27;$&#x27;);
        } else {
            window.__cov_seq = window.__cov_seq || 0;
            window.__cov_seq += 1;
            suffix = window.__cov_seq;
        }
        return &#x27;__cov_&#x27; + (omitSuffix ? &#x27;&#x27; : suffix);
    }

    function pushAll(ary, thing) {
        if (!isArray(thing)) {
            thing = [ thing ];
        }
        Array.prototype.push.apply(ary, thing);
    }

    SYNTAX = {
        ArrayExpression: [ &#x27;elements&#x27; ],
        AssignmentExpression: [&#x27;left&#x27;, &#x27;right&#x27;],
        BinaryExpression: [&#x27;left&#x27;, &#x27;right&#x27; ],
        BlockStatement: [ &#x27;body&#x27; ],
        BreakStatement: [ &#x27;label&#x27; ],
        CallExpression: [ &#x27;callee&#x27;, &#x27;arguments&#x27;],
        CatchClause: [&#x27;param&#x27;, &#x27;body&#x27;],
        ConditionalExpression: [ &#x27;test&#x27;, &#x27;consequent&#x27;, &#x27;alternate&#x27; ],
        ContinueStatement: [ &#x27;label&#x27; ],
        DebuggerStatement: [ ],
        DoWhileStatement: [ &#x27;test&#x27;, &#x27;body&#x27; ],
        EmptyStatement: [],
        ExpressionStatement: [ &#x27;expression&#x27;],
        ForInStatement: [ &#x27;left&#x27;, &#x27;right&#x27;, &#x27;body&#x27; ],
        ForStatement: [&#x27;init&#x27;, &#x27;test&#x27;, &#x27;update&#x27;, &#x27;body&#x27; ],
        FunctionDeclaration: [&#x27;id&#x27;, &#x27;params&#x27;, &#x27;body&#x27;],
        FunctionExpression: [&#x27;id&#x27;, &#x27;params&#x27;, &#x27;defaults&#x27;, &#x27;body&#x27;],
        Identifier: [],
        IfStatement: [&#x27;test&#x27;, &#x27;consequent&#x27;, &#x27;alternate&#x27;],
        LabeledStatement: [&#x27;label&#x27;, &#x27;body&#x27;],
        Literal: [],
        LogicalExpression: [ &#x27;left&#x27;, &#x27;right&#x27; ],
        MemberExpression: [&#x27;object&#x27;, &#x27;property&#x27;],
        NewExpression: [&#x27;callee&#x27;, &#x27;arguments&#x27;],
        ObjectExpression: [ &#x27;properties&#x27; ],
        Program: [ &#x27;body&#x27; ],
        Property: [ &#x27;key&#x27;, &#x27;value&#x27;],
        ReturnStatement: [&#x27;argument&#x27;],
        SequenceExpression: [&#x27;expressions&#x27;],
        SwitchCase: [ &#x27;test&#x27;, &#x27;consequent&#x27; ],
        SwitchStatement: [&#x27;discriminant&#x27;, &#x27;cases&#x27; ],
        ThisExpression: [],
        ThrowStatement: [&#x27;argument&#x27;],
        TryStatement: [ &#x27;block&#x27;, &#x27;handlers&#x27;, &#x27;finalizer&#x27; ],
        UnaryExpression: [&#x27;argument&#x27;],
        UpdateExpression: [ &#x27;argument&#x27; ],
        VariableDeclaration: [ &#x27;declarations&#x27; ],
        VariableDeclarator: [ &#x27;id&#x27;, &#x27;init&#x27; ],
        WhileStatement: [ &#x27;test&#x27;, &#x27;body&#x27; ],
        WithStatement: [ &#x27;object&#x27;, &#x27;body&#x27; ]

    };

    for (nodeType in SYNTAX) {
        /* istanbul ignore else: has own property */
        if (SYNTAX.hasOwnProperty(nodeType)) {
            SYNTAX[nodeType] = { name: nodeType, children: SYNTAX[nodeType] };
        }
    }

    astgen = {
        variable: function (name) { return { type: SYNTAX.Identifier.name, name: name }; },
        stringLiteral: function (str) { return { type: SYNTAX.Literal.name, value: String(str) }; },
        numericLiteral: function (num) { return { type: SYNTAX.Literal.name, value: Number(num) }; },
        statement: function (contents) { return { type: SYNTAX.ExpressionStatement.name, expression: contents }; },
        dot: function (obj, field) { return { type: SYNTAX.MemberExpression.name, computed: false, object: obj, property: field }; },
        subscript: function (obj, sub) { return { type: SYNTAX.MemberExpression.name, computed: true, object: obj, property: sub }; },
        postIncrement: function (obj) { return { type: SYNTAX.UpdateExpression.name, operator: &#x27;++&#x27;, prefix: false, argument: obj }; },
        sequence: function (one, two) { return { type: SYNTAX.SequenceExpression.name, expressions: [one, two] }; }
    };

    function Walker(walkMap, preprocessor, scope, debug) {
        this.walkMap = walkMap;
        this.preprocessor = preprocessor;
        this.scope = scope;
        this.debug = debug;
        if (this.debug) {
            this.level = 0;
            this.seq = true;
        }
    }

    function defaultWalker(node, walker) {

        var type = node.type,
            preprocessor,
            postprocessor,
            children = SYNTAX[type].children,
            // don&#x27;t run generated nodes thru custom walks otherwise we will attempt to instrument the instrumentation code :)
            applyCustomWalker = !!node.loc || node.type === SYNTAX.Program.name,
            walkerFn = applyCustomWalker ? walker.walkMap[type] : null,
            i,
            j,
            walkFnIndex,
            childType,
            childNode,
            ret,
            childArray,
            childElement,
            pathElement,
            assignNode,
            isLast;

        /* istanbul ignore if: guard */
        if (node.walking) { throw new Error(&#x27;Infinite regress: Custom walkers may NOT call walker.apply(node)&#x27;); }
        node.walking = true;

        ret = walker.apply(node, walker.preprocessor);

        preprocessor = ret.preprocessor;
        if (preprocessor) {
            delete ret.preprocessor;
            ret = walker.apply(node, preprocessor);
        }

        if (isArray(walkerFn)) {
            for (walkFnIndex = 0; walkFnIndex &lt; walkerFn.length; walkFnIndex += 1) {
                isLast = walkFnIndex === walkerFn.length - 1;
                ret = walker.apply(ret, walkerFn[walkFnIndex]);
                /*istanbul ignore next: paranoid check */
                if (ret.type !== type &amp;&amp; !isLast) {
                    throw new Error(&#x27;Only the last walker is allowed to change the node type: [type was: &#x27; + type + &#x27; ]&#x27;);
                }
            }
        } else {
            if (walkerFn) {
                ret = walker.apply(node, walkerFn);
            }
        }

        for (i = 0; i &lt; children.length; i += 1) {
            childType = children[i];
            childNode = node[childType];
            if (childNode &amp;&amp; !childNode.skipWalk) {
                pathElement = { node: node, property: childType };
                if (isArray(childNode)) {
                    childArray = [];
                    for (j = 0; j &lt; childNode.length; j += 1) {
                        childElement = childNode[j];
                        pathElement.index = j;
                        if (childElement) {
                          assignNode = walker.apply(childElement, null, pathElement);
                          if (isArray(assignNode.prepend)) {
                              pushAll(childArray, assignNode.prepend);
                              delete assignNode.prepend;
                          }
                        }
                        pushAll(childArray, assignNode);
                    }
                    node[childType] = childArray;
                } else {
                    assignNode = walker.apply(childNode, null, pathElement);
                    /*istanbul ignore if: paranoid check */
                    if (isArray(assignNode.prepend)) {
                        throw new Error(&#x27;Internal error: attempt to prepend statements in disallowed (non-array) context&#x27;);
                        /* if this should be allowed, this is how to solve it
                        tmpNode = { type: &#x27;BlockStatement&#x27;, body: [] };
                        pushAll(tmpNode.body, assignNode.prepend);
                        pushAll(tmpNode.body, assignNode);
                        node[childType] = tmpNode;
                        delete assignNode.prepend;
                        */
                    } else {
                        node[childType] = assignNode;
                    }
                }
            }
        }

        postprocessor = ret.postprocessor;
        if (postprocessor) {
            delete ret.postprocessor;
            ret = walker.apply(ret, postprocessor);
        }

        delete node.walking;

        return ret;
    }

    Walker.prototype = {
        startWalk: function (node) {
            this.path = [];
            this.apply(node);
        },

        apply: function (node, walkFn, pathElement) {
            var ret, i, seq, prefix;

            walkFn = walkFn || defaultWalker;
            if (this.debug) {
                this.seq += 1;
                this.level += 1;
                seq = this.seq;
                prefix = &#x27;&#x27;;
                for (i = 0; i &lt; this.level; i += 1) { prefix += &#x27;    &#x27;; }
                console.log(prefix + &#x27;Enter (&#x27; + seq + &#x27;):&#x27; + node.type);
            }
            if (pathElement) { this.path.push(pathElement); }
            ret = walkFn.call(this.scope, node, this);
            if (pathElement) { this.path.pop(); }
            if (this.debug) {
                this.level -= 1;
                console.log(prefix + &#x27;Return (&#x27; + seq + &#x27;):&#x27; + node.type);
            }
            return ret || node;
        },

        startLineForNode: function (node) {
            return node &amp;&amp; node.loc &amp;&amp; node.loc.start ? node.loc.start.line : /* istanbul ignore next: guard */ null;
        },

        ancestor: function (n) {
            return this.path.length &gt; n - 1 ? this.path[this.path.length - n] : /* istanbul ignore next: guard */ null;
        },

        parent: function () {
            return this.ancestor(1);
        },

        isLabeled: function () {
            var el = this.parent();
            return el &amp;&amp; el.node.type === SYNTAX.LabeledStatement.name;
        }
    };

    /**
     * mechanism to instrument code for coverage. It uses the &#x60;esprima&#x60; and
     * &#x60;escodegen&#x60; libraries for JS parsing and code generation respectively.
     *
     * Works on &#x60;node&#x60; as well as the browser.
     *
     * Usage on nodejs
     * ---------------
     *
     *      var instrumenter = new require(&#x27;istanbul&#x27;).Instrumenter(),
     *          changed = instrumenter.instrumentSync(&#x27;function meaningOfLife() { return 42; }&#x27;, &#x27;filename.js&#x27;);
     *
     * Usage in a browser
     * ------------------
     *
     * Load &#x60;esprima.js&#x60;, &#x60;escodegen.js&#x60; and &#x60;instrumenter.js&#x60; (this file) using &#x60;script&#x60; tags or other means.
     *
     * Create an instrumenter object as:
     *
     *      var instrumenter = new Instrumenter(),
     *          changed = instrumenter.instrumentSync(&#x27;function meaningOfLife() { return 42; }&#x27;, &#x27;filename.js&#x27;);
     *
     * Aside from demonstration purposes, it is unclear why you would want to instrument code in a browser.
     *
     * @class Instrumenter
     * @constructor
     * @param {Object} options Optional. Configuration options.
     * @param {String} [options.coverageVariable] the global variable name to use for
     *      tracking coverage. Defaults to &#x60;__coverage__&#x60;
     * @param {Boolean} [options.embedSource] whether to embed the source code of every
     *      file as an array in the file coverage object for that file. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.preserveComments] whether comments should be preserved in the output. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.noCompact] emit readable code when set. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.noAutoWrap] do not automatically wrap the source in
     *      an anonymous function before covering it. By default, code is wrapped in
     *      an anonymous function before it is parsed. This is done because
     *      some nodejs libraries have &#x60;return&#x60; statements outside of
     *      a function which is technically invalid Javascript and causes the parser to fail.
     *      This construct, however, works correctly in node since module loading
     *      is done in the context of an anonymous function.
     *
     * Note that the semantics of the code *returned* by the instrumenter does not change in any way.
     * The function wrapper is &quot;unwrapped&quot; before the instrumented code is generated.
     * @param {Object} [options.codeGenerationOptions] an object that is directly passed to the &#x60;escodegen&#x60;
     *      library as configuration for code generation. The &#x60;noCompact&#x60; setting is not honored when this
     *      option is specified
     * @param {Boolean} [options.debug] assist in debugging. Currently, the only effect of
     *      setting this option is a pretty-print of the coverage variable. Defaults to &#x60;false&#x60;
     * @param {Boolean} [options.walkDebug] assist in debugging of the AST walker used by this class.
     *
     */
    function Instrumenter(options) {
        this.opts = options || {
            debug: false,
            walkDebug: false,
            coverageVariable: &#x27;__coverage__&#x27;,
            codeGenerationOptions: undefined,
            noAutoWrap: false,
            noCompact: false,
            embedSource: false,
            preserveComments: false
        };

        this.walker = new Walker({
            ExpressionStatement: this.coverStatement,
            BreakStatement: this.coverStatement,
            ContinueStatement: this.coverStatement,
            DebuggerStatement: this.coverStatement,
            ReturnStatement: this.coverStatement,
            ThrowStatement: this.coverStatement,
            TryStatement: this.coverStatement,
            VariableDeclaration: this.coverStatement,
            IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
            ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
            ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
            WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
            SwitchCase: [ this.switchCaseInjector ],
            WithStatement: [ this.withBlockConverter, this.coverStatement ],
            FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
            FunctionExpression: this.coverFunction,
            LabeledStatement: this.coverStatement,
            ConditionalExpression: this.conditionalBranchInjector,
            LogicalExpression: this.logicalExpressionBranchInjector,
            ObjectExpression: this.maybeAddType
        }, this.extractCurrentHint, this, this.opts.walkDebug);

        //unit testing purposes only
        if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
            this.omitTrackerSuffix = true;
        }
    }

    Instrumenter.prototype = {
        /**
         * synchronous instrumentation method. Throws when illegal code is passed to it
         * @method instrumentSync
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         */
        instrumentSync: function (code, filename) {
            var program;

            //protect from users accidentally passing in a Buffer object instead
            if (typeof code !== &#x27;string&#x27;) { throw new Error(&#x27;Code must be string&#x27;); }
            if (code.charAt(0) === &#x27;#&#x27;) { //shebang, &#x27;comment&#x27; it out, won&#x27;t affect syntax tree locations for things we care about
                code = &#x27;//&#x27; + code;
            }
            if (!this.opts.noAutoWrap) {
                code = LEADER_WRAP + code + TRAILER_WRAP;
            }
            program = ESP.parse(code, {
                loc: true,
                range: true,
                tokens: this.opts.preserveComments,
                comment: true
            });
            if (this.opts.preserveComments) {
                program = ESPGEN.attachComments(program, program.comments, program.tokens);
            }
            if (!this.opts.noAutoWrap) {
                program = {
                    type: SYNTAX.Program.name,
                    body: program.body[0].expression.callee.body.body,
                    comments: program.comments
                };
            }
            return this.instrumentASTSync(program, filename, code);
        },
        filterHints: function (comments) {
            var ret = [],
                i,
                comment,
                groups;
            if (!(comments &amp;&amp; isArray(comments))) {
                return ret;
            }
            for (i = 0; i &lt; comments.length; i += 1) {
                comment = comments[i];
                /* istanbul ignore else: paranoid check */
                if (comment &amp;&amp; comment.value &amp;&amp; comment.range &amp;&amp; isArray(comment.range)) {
                    groups = String(comment.value).match(COMMENT_RE);
                    if (groups) {
                        ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });
                    }
                }
            }
            return ret;
        },
        extractCurrentHint: function (node) {
            if (!node.range) { return; }
            var i = this.currentState.lastHintPosition + 1,
                hints = this.currentState.hints,
                nodeStart = node.range[0],
                hint;
            this.currentState.currentHint = null;
            while (i &lt; hints.length) {
                hint = hints[i];
                if (hint.end &lt; nodeStart) {
                    this.currentState.currentHint = hint;
                    this.currentState.lastHintPosition = i;
                    i += 1;
                } else {
                    break;
                }
            }
        },
        /**
         * synchronous instrumentation method that instruments an AST instead.
         * @method instrumentASTSync
         * @param {String} program the AST to be instrumented
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         *  @param {String} originalCode the original code corresponding to the AST,
         *  used for embedding the source into the coverage object
         */
        instrumentASTSync: function (program, filename, originalCode) {
            var usingStrict = false,
                codegenOptions,
                generated,
                preamble,
                lineCount,
                i;
            filename = filename || String(new Date().getTime()) + &#x27;.js&#x27;;
            this.sourceMap = null;
            this.coverState = {
                path: filename,
                s: {},
                b: {},
                f: {},
                fnMap: {},
                statementMap: {},
                branchMap: {}
            };
            this.currentState = {
                trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
                func: 0,
                branch: 0,
                variable: 0,
                statement: 0,
                hints: this.filterHints(program.comments),
                currentHint: null,
                lastHintPosition: -1,
                ignoring: 0
            };
            if (program.body &amp;&amp; program.body.length &gt; 0 &amp;&amp; this.isUseStrictExpression(program.body[0])) {
                //nuke it
                program.body.shift();
                //and add it back at code generation time
                usingStrict = true;
            }
            this.walker.startWalk(program);
            codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
            codegenOptions.comment = this.opts.preserveComments;
            //console.log(JSON.stringify(program, undefined, 2));

            generated = ESPGEN.generate(program, codegenOptions);
            preamble = this.getPreamble(originalCode || &#x27;&#x27;, usingStrict);

            if (generated.map &amp;&amp; generated.code) {
                lineCount = preamble.split(/\r\n|\r|\n/).length;
                // offset all the generated line numbers by the number of lines in the preamble
                for (i = 0; i &lt; generated.map._mappings.length; i += 1) {
                    generated.map._mappings[i].generatedLine += lineCount;
                }
                this.sourceMap = generated.map;
                generated = generated.code;
            }

            return preamble + &#x27;\n&#x27; + generated + &#x27;\n&#x27;;
        },
        /**
         * Callback based instrumentation. Note that this still executes synchronously in the same process tick
         * and calls back immediately. It only provides the options for callback style error handling as
         * opposed to a &#x60;try-catch&#x60; style and nothing more. Implemented as a wrapper over &#x60;instrumentSync&#x60;
         *
         * @method instrument
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         * @param {Function(err, instrumentedCode)} callback - the callback function
         */
        instrument: function (code, filename, callback) {

            if (!callback &amp;&amp; typeof filename === &#x27;function&#x27;) {
                callback = filename;
                filename = null;
            }
            try {
                callback(null, this.instrumentSync(code, filename));
            } catch (ex) {
                callback(ex);
            }
        },
        /**
         * returns the file coverage object for the code that was instrumented
         * just before calling this method. Note that this represents a
         * &quot;zero-coverage&quot; object which is not even representative of the code
         * being loaded in node or a browser (which would increase the statement
         * counts for mainline code).
         * @method lastFileCoverage
         * @return {Object} a &quot;zero-coverage&quot; file coverage object for the code last instrumented
         * by this instrumenter
         */
        lastFileCoverage: function () {
            return this.coverState;
        },
        /**
         * returns the source map object for the code that was instrumented
         * just before calling this method.
         * @method lastSourceMap
         * @return {Object} a source map object for the code last instrumented
         * by this instrumenter
         */
        lastSourceMap: function () {
            return this.sourceMap;
        },
        fixColumnPositions: function (coverState) {
            var offset = LEADER_WRAP.length,
                fixer = function (loc) {
                    if (loc.start.line === 1) {
                        loc.start.column -= offset;
                    }
                    if (loc.end.line === 1) {
                        loc.end.column -= offset;
                    }
                },
                k,
                obj,
                i,
                locations;

            obj = coverState.statementMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
            }
            obj = coverState.fnMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
            }
            obj = coverState.branchMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) {
                    locations = obj[k].locations;
                    for (i = 0; i &lt; locations.length; i += 1) {
                        fixer(locations[i]);
                    }
                }
            }
        },

        getPreamble: function (sourceCode, emitUseStrict) {
            var varName = this.opts.coverageVariable || &#x27;__coverage__&#x27;,
                file = this.coverState.path.replace(/\\/g, &#x27;\\\\&#x27;),
                tracker = this.currentState.trackerVar,
                coverState,
                strictLine = emitUseStrict ? &#x27;&quot;use strict&quot;;&#x27; : &#x27;&#x27;,
                // return replacements using the function to ensure that the replacement is
                // treated like a dumb string and not as a string with RE replacement patterns
                replacer = function (s) {
                    return function () { return s; };
                },
                code;
            if (!this.opts.noAutoWrap) {
                this.fixColumnPositions(this.coverState);
            }
            if (this.opts.embedSource) {
                this.coverState.code = sourceCode.split(/(?:\r?\n)|\r/);
            }
            coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
            code = [
                &quot;%STRICT%&quot;,
                &quot;var %VAR% = (Function(&#x27;return this&#x27;))();&quot;,
                &quot;if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }&quot;,
                &quot;%VAR% = %VAR%.%GLOBAL%;&quot;,
                &quot;if (!(%VAR%[&#x27;%FILE%&#x27;])) {&quot;,
                &quot;   %VAR%[&#x27;%FILE%&#x27;] = %OBJECT%;&quot;,
                &quot;}&quot;,
                &quot;%VAR% = %VAR%[&#x27;%FILE%&#x27;];&quot;
            ].join(&quot;\n&quot;)
                .replace(/%STRICT%/g, replacer(strictLine))
                .replace(/%VAR%/g, replacer(tracker))
                .replace(/%GLOBAL%/g, replacer(varName))
                .replace(/%FILE%/g, replacer(file))
                .replace(/%OBJECT%/g, replacer(coverState));
            return code;
        },

        startIgnore: function () {
            this.currentState.ignoring += 1;
        },

        endIgnore: function () {
            this.currentState.ignoring -= 1;
        },

        convertToBlock: function (node) {
            if (!node) {
                return { type: &#x27;BlockStatement&#x27;, body: [] };
            } else if (node.type === &#x27;BlockStatement&#x27;) {
                return node;
            } else {
                return { type: &#x27;BlockStatement&#x27;, body: [ node ] };
            }
        },

        ifBlockConverter: function (node) {
            node.consequent = this.convertToBlock(node.consequent);
            node.alternate = this.convertToBlock(node.alternate);
        },

        loopBlockConverter: function (node) {
            node.body = this.convertToBlock(node.body);
        },

        withBlockConverter: function (node) {
            node.body = this.convertToBlock(node.body);
        },

        statementName: function (location, initValue) {
            var sName,
                ignoring = !!this.currentState.ignoring;

            location.skip = ignoring || undefined;
            initValue = initValue || 0;
            this.currentState.statement += 1;
            sName = this.currentState.statement;
            this.coverState.statementMap[sName] = location;
            this.coverState.s[sName] = initValue;
            return sName;
        },

        skipInit: function (node /*, walker */) {
            if (node.init) {
                node.init.skipWalk = true;
            }
        },

        skipLeft: function (node /*, walker */) {
            node.left.skipWalk = true;
        },

        isUseStrictExpression: function (node) {
            return node &amp;&amp; node.type === SYNTAX.ExpressionStatement.name &amp;&amp;
                node.expression  &amp;&amp; node.expression.type === SYNTAX.Literal.name &amp;&amp;
                node.expression.value === &#x27;use strict&#x27;;
        },

        maybeSkipNode: function (node, type) {
            var alreadyIgnoring = !!this.currentState.ignoring,
                hint = this.currentState.currentHint,
                ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === type;

            if (ignoreThis) {
                this.startIgnore();
                node.postprocessor = this.endIgnore;
                return true;
            }
            return false;
        },

        coverStatement: function (node, walker) {
            var sName,
                incrStatementCount,
                grandParent;

            this.maybeSkipNode(node, &#x27;next&#x27;);

            if (this.isUseStrictExpression(node)) {
                grandParent = walker.ancestor(2);
                /* istanbul ignore else: difficult to test */
                if (grandParent) {
                    if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||
                        grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &amp;&amp;
                        walker.parent().node.body[0] === node) {
                        return;
                    }
                }
            }
            if (node.type === SYNTAX.FunctionDeclaration.name) {
                sName = this.statementName(node.loc, 1);
            } else {
                sName = this.statementName(node.loc);
                incrStatementCount = astgen.statement(
                    astgen.postIncrement(
                        astgen.subscript(
                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;s&#x27;)),
                            astgen.stringLiteral(sName)
                        )
                    )
                );
                this.splice(incrStatementCount, node, walker);
            }
        },

        splice: function (statements, node, walker) {
            var targetNode = walker.isLabeled() ? walker.parent().node : node;
            targetNode.prepend = targetNode.prepend || [];
            pushAll(targetNode.prepend, statements);
        },

        functionName: function (node, line, location) {
            this.currentState.func += 1;
            var id = this.currentState.func,
                ignoring = !!this.currentState.ignoring,
                name = node.id ? node.id.name : &#x27;(anonymous_&#x27; + id + &#x27;)&#x27;;
            this.coverState.fnMap[id] = { name: name, line: line, loc: location, skip: ignoring || undefined };
            this.coverState.f[id] = 0;
            return id;
        },

        coverFunction: function (node, walker) {
            var id,
                body = node.body,
                blockBody = body.body,
                popped;

            this.maybeSkipNode(node, &#x27;next&#x27;);

            id = this.functionName(node, walker.startLineForNode(node), {
                start: node.loc.start,
                end: { line: node.body.loc.start.line, column: node.body.loc.start.column }
            });

            if (blockBody.length &gt; 0 &amp;&amp; this.isUseStrictExpression(blockBody[0])) {
                popped = blockBody.shift();
            }
            blockBody.unshift(
                astgen.statement(
                    astgen.postIncrement(
                        astgen.subscript(
                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;f&#x27;)),
                            astgen.stringLiteral(id)
                        )
                    )
                )
            );
            if (popped) {
                blockBody.unshift(popped);
            }
        },

        branchName: function (type, startLine, pathLocations) {
            var bName,
                paths = [],
                locations = [],
                i,
                ignoring = !!this.currentState.ignoring;
            this.currentState.branch += 1;
            bName = this.currentState.branch;
            for (i = 0; i &lt; pathLocations.length; i += 1) {
                pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;
                locations.push(pathLocations[i]);
                paths.push(0);
            }
            this.coverState.b[bName] = paths;
            this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
            return bName;
        },

        branchIncrementExprAst: function (varName, branchIndex, down) {
            var ret = astgen.postIncrement(
                astgen.subscript(
                    astgen.subscript(
                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&#x27;b&#x27;)),
                        astgen.stringLiteral(varName)
                    ),
                    astgen.numericLiteral(branchIndex)
                ),
                down
            );
            return ret;
        },

        locationsForNodes: function (nodes) {
            var ret = [],
                i;
            for (i = 0; i &lt; nodes.length; i += 1) {
                ret.push(nodes[i].loc);
            }
            return ret;
        },

        ifBranchInjector: function (node, walker) {
            var alreadyIgnoring = !!this.currentState.ignoring,
                hint = this.currentState.currentHint,
                ignoreThen = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &#x27;if&#x27;,
                ignoreElse = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &#x27;else&#x27;,
                line = node.loc.start.line,
                col = node.loc.start.column,
                start = { line: line, column: col },
                end = { line: line, column: col },
                bName = this.branchName(&#x27;if&#x27;, walker.startLineForNode(node), [
                    { start: start, end: end, skip: ignoreThen || undefined },
                    { start: start, end: end, skip: ignoreElse || undefined }
                ]),
                thenBody = node.consequent.body,
                elseBody = node.alternate.body,
                child;
            thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
            elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
            if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
            if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
        },

        branchLocationFor: function (name, index) {
            return this.coverState.branchMap[name].locations[index];
        },

        switchBranchInjector: function (node, walker) {
            var cases = node.cases,
                bName,
                i;

            if (!(cases &amp;&amp; cases.length &gt; 0)) {
                return;
            }
            bName = this.branchName(&#x27;switch&#x27;, walker.startLineForNode(node), this.locationsForNodes(cases));
            for (i = 0; i &lt; cases.length; i += 1) {
                cases[i].branchLocation = this.branchLocationFor(bName, i);
                cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
            }
        },

        switchCaseInjector: function (node) {
            var location = node.branchLocation;
            delete node.branchLocation;
            if (this.maybeSkipNode(node, &#x27;next&#x27;)) {
                location.skip = true;
            }
        },

        conditionalBranchInjector: function (node, walker) {
            var bName = this.branchName(&#x27;cond-expr&#x27;, walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate ])),
                ast1 = this.branchIncrementExprAst(bName, 0),
                ast2 = this.branchIncrementExprAst(bName, 1);

            node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));
            node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));
            node.consequent = astgen.sequence(ast1, node.consequent);
            node.alternate = astgen.sequence(ast2, node.alternate);
        },

        maybeAddSkip: function (branchLocation) {
            return function (node) {
                var alreadyIgnoring = !!this.currentState.ignoring,
                    hint = this.currentState.currentHint,
                    ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &#x27;next&#x27;;
                if (ignoreThis) {
                    this.startIgnore();
                    node.postprocessor = this.endIgnore;
                }
                if (ignoreThis || alreadyIgnoring) {
                    branchLocation.skip = true;
                }
            };
        },

        logicalExpressionBranchInjector: function (node, walker) {
            var parent = walker.parent(),
                leaves = [],
                bName,
                tuple,
                i;

            this.maybeSkipNode(node, &#x27;next&#x27;);

            if (parent &amp;&amp; parent.node.type === SYNTAX.LogicalExpression.name) {
                //already covered
                return;
            }

            this.findLeaves(node, leaves);
            bName = this.branchName(&#x27;binary-expr&#x27;,
                walker.startLineForNode(node),
                this.locationsForNodes(leaves.map(function (item) { return item.node; }))
            );
            for (i = 0; i &lt; leaves.length; i += 1) {
                tuple = leaves[i];
                tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
                tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));
            }
        },

        findLeaves: function (node, accumulator, parent, property) {
            if (node.type === SYNTAX.LogicalExpression.name) {
                this.findLeaves(node.left, accumulator, node, &#x27;left&#x27;);
                this.findLeaves(node.right, accumulator, node, &#x27;right&#x27;);
            } else {
                accumulator.push({ node: node, parent: parent, property: property });
            }
        },
        maybeAddType: function (node /*, walker */) {
            var props = node.properties,
                i,
                child;
            for (i = 0; i &lt; props.length; i += 1) {
                child = props[i];
                if (!child.type) {
                    child.type = SYNTAX.Property.name;
                }
            }
        }
    };

    if (isNode) {
        module.exports = Instrumenter;
    } else {
        window.Instrumenter = Instrumenter;
    }

}(typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof module.exports !== &#x27;undefined&#x27; &amp;&amp; typeof exports !== &#x27;undefined&#x27;));


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
